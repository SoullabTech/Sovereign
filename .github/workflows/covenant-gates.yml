# MAIA Mentor Covenant â€” Enforcement Gates
# See docs/GOVERNANCE_MENTOR_COVENANT.md for full governance rules
#
# Core principle: "MAIA proposes; Mentors approve; Production is human-signed."

name: Covenant Gates

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted, edited, dismissed]

jobs:
  covenant-gates:
    runs-on: ubuntu-latest
    steps:
      - name: Enforce covenant gates
        uses: actions/github-script@v7
        with:
          script: |
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GOVERNANCE CONFIGURATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const FOUNDERS = ['kelly-nezat'];
            const GUARDIAN_CIRCLE = []; // Add council usernames when appointed
            const MENTORS = [];          // Add mentor usernames when appointed

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // APPROVAL REQUIREMENTS BY CLASS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const REQUIREMENTS = {
              'class-a': {
                founderRequired: true,
                councilRequired: 2,
                mentorRequired: 1,
                description: 'Sacred Boundaries (privacy/consent/safety/sovereignty)'
              },
              'class-b': {
                founderOrReleaseRequired: true,
                mentorRequired: 1,
                rollbackRequired: true,
                description: 'Structural Risk (migrations/auth/routing/infra)'
              },
              'class-c': {
                mentorRequired: 1,
                ciRequired: true,
                description: 'Routine Improvement (refactor/copy/UX/prompt tuning)'
              },
              'frontier-dependent': {
                founderRequired: true,
                mentorRequired: 1,
                verificationRequired: true,
                revalidationRequired: true,
                description: 'Frontier-Dependent (models/providers/pricing)'
              }
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PARSE PR BODY FOR CLASSIFICATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const pr = context.payload.pull_request;
            const body = pr.body || '';
            const labels = pr.labels.map(l => l.name);

            // Detect classification from checkbox or label
            const classAChecked = body.includes('[x] **Class A');
            const classBChecked = body.includes('[x] **Class B');
            const classCChecked = body.includes('[x] **Class C');
            const frontierChecked = body.includes('[x] **Frontier-Dependent');

            const hasClassA = classAChecked || labels.includes('class-a');
            const hasClassB = classBChecked || labels.includes('class-b');
            const hasClassC = classCChecked || labels.includes('class-c');
            const hasFrontier = frontierChecked || labels.includes('frontier-dependent');

            // Determine effective class (highest takes precedence)
            let effectiveClass = null;
            if (hasClassA) effectiveClass = 'class-a';
            else if (hasFrontier) effectiveClass = 'frontier-dependent';
            else if (hasClassB) effectiveClass = 'class-b';
            else if (hasClassC) effectiveClass = 'class-c';

            if (!effectiveClass) {
              core.setFailed(
                'âŒ No change classification found.\n\n' +
                'Please check one of the classification boxes in the PR template:\n' +
                '- [ ] Class A â€” Sacred Boundaries\n' +
                '- [ ] Class B â€” Structural Risk\n' +
                '- [ ] Class C â€” Routine Improvement\n' +
                '- [ ] Frontier-Dependent'
              );
              return;
            }

            console.log(`ğŸ“‹ Classification: ${effectiveClass}`);
            const reqs = REQUIREMENTS[effectiveClass];
            console.log(`ğŸ“œ Requirements: ${reqs.description}`);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GET APPROVALS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            // Get most recent review per user (only APPROVED counts)
            const approvalsByUser = {};
            for (const review of reviews) {
              if (review.state === 'APPROVED') {
                approvalsByUser[review.user.login] = review;
              } else if (review.state === 'CHANGES_REQUESTED' || review.state === 'DISMISSED') {
                delete approvalsByUser[review.user.login];
              }
            }

            const approvers = Object.keys(approvalsByUser);
            console.log(`âœ… Approvers: ${approvers.join(', ') || '(none)'}`);

            // Categorize approvers
            const founderApprovals = approvers.filter(u => FOUNDERS.includes(u));
            const councilApprovals = approvers.filter(u => GUARDIAN_CIRCLE.includes(u));
            const mentorApprovals = approvers.filter(u => MENTORS.includes(u));

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // VALIDATE REQUIREMENTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const failures = [];

            // Class A requirements
            if (reqs.founderRequired && founderApprovals.length === 0) {
              failures.push(`Founder-Steward approval required (need 1 of: ${FOUNDERS.join(', ')})`);
            }

            if (reqs.councilRequired) {
              if (GUARDIAN_CIRCLE.length === 0) {
                console.log('âš ï¸ Guardian Circle not yet configured - skipping council check');
              } else if (councilApprovals.length < reqs.councilRequired) {
                failures.push(`Guardian Circle approval required (need ${reqs.councilRequired}, have ${councilApprovals.length})`);
              }
            }

            if (reqs.mentorRequired) {
              if (MENTORS.length === 0) {
                console.log('âš ï¸ Mentors not yet configured - skipping mentor check');
              } else if (mentorApprovals.length < reqs.mentorRequired) {
                failures.push(`Mentor approval required (need ${reqs.mentorRequired}, have ${mentorApprovals.length})`);
              }
            }

            // Class B: Founder OR Release Steward
            if (reqs.founderOrReleaseRequired) {
              const hasFounderOrSteward = founderApprovals.length > 0 ||
                approvers.some(u => MENTORS.includes(u)); // Release steward is a designated mentor
              if (!hasFounderOrSteward) {
                failures.push(`Founder-Steward OR Release Steward approval required`);
              }
            }

            // Rollback plan check for Class B
            if (reqs.rollbackRequired) {
              const hasRollbackPlan =
                body.includes('[x] Revert commit is sufficient') ||
                body.includes('[x] Migration rollback script provided') ||
                body.includes('[x] Feature flag can disable') ||
                body.includes('[x] **No rollback possible**');

              if (!hasRollbackPlan) {
                failures.push('Rollback plan required - check one of the rollback options in the PR template');
              }
            }

            // Frontier verification check
            if (reqs.verificationRequired) {
              const hasVerification = body.includes('[x] Verified by Mentor:');
              if (!hasVerification) {
                failures.push('Frontier verification required - a Mentor must verify external dependencies');
              }

              // Check for revalidation date
              if (reqs.revalidationRequired) {
                const hasRevalidation = body.toLowerCase().includes('revalidat') ||
                                        body.toLowerCase().includes('expires') ||
                                        body.toLowerCase().includes('valid until');
                if (!hasRevalidation) {
                  console.log('âš ï¸ Consider adding revalidation date for frontier-dependent changes');
                }
              }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FILE PATH SAFETY RAILS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const changedPaths = files.map(f => f.filename);

            // Sacred paths require Class A
            const sacredPaths = [
              'lib/safety/',
              'lib/memory/',
              'lib/consciousness/',
              'docs/policy/',
              'docs/GOVERNANCE'
            ];

            const touchesSacred = changedPaths.some(p =>
              sacredPaths.some(sacred => p.startsWith(sacred))
            );

            if (touchesSacred && effectiveClass !== 'class-a') {
              failures.push(
                'This PR modifies Sacred Boundary files but is not classified as Class A.\n' +
                'Please update classification to Class A for files in: ' +
                sacredPaths.join(', ')
              );
            }

            // Migration paths require at least Class B
            const touchesMigrations = changedPaths.some(p => p.startsWith('database/migrations/'));
            if (touchesMigrations && effectiveClass === 'class-c') {
              failures.push(
                'This PR modifies database migrations but is classified as Class C.\n' +
                'Please update classification to at least Class B.'
              );
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // REPORT RESULTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            if (failures.length > 0) {
              const message =
                `âŒ Covenant Gates Failed for ${effectiveClass}\n\n` +
                `**${reqs.description}**\n\n` +
                `Missing requirements:\n` +
                failures.map(f => `- ${f}`).join('\n') +
                `\n\n` +
                `See [GOVERNANCE_MENTOR_COVENANT.md](../docs/GOVERNANCE_MENTOR_COVENANT.md) for details.\n\n` +
                `*"MAIA proposes; Mentors approve; Production is human-signed."*`;

              core.setFailed(message);
            } else {
              console.log(`âœ… All covenant gates passed for ${effectiveClass}`);
              console.log(`   Founder approvals: ${founderApprovals.length}`);
              console.log(`   Council approvals: ${councilApprovals.length}`);
              console.log(`   Mentor approvals: ${mentorApprovals.length}`);
            }
