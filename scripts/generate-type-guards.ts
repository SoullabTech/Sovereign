#!/usr/bin/env tsx
/**
 * Stage 4.2a â€“ Type-Guard Generation Engine
 * ------------------------------------------
 * Reads type-guard-map.json and generates contextual runtime type guards
 * based on detected unsafe property access patterns.
 *
 * Modes:
 *  â€¢ --dry-run: Generate guard templates without writing (default)
 *  â€¢ --apply: Write guards to lib/utils/type-guards.ts
 *
 * Output â†’ artifacts/type-guard-templates.json (always)
 *          lib/utils/type-guards.ts (only with --apply)
 */

import fs from "fs";
import path from "path";

const MAP_PATH = "artifacts/type-guard-map.json";
const TEMPLATES_PATH = "artifacts/type-guard-templates.json";
const CONFIG_PATH = "phase4.2a-config.json";
const OUTPUT_FILE = "lib/utils/type-guards.ts";

interface TypeGuardCluster {
  guardName: string;
  pattern: "propertyCheck" | "typeAssertion" | "arrayGuard";
  targetProperty?: string;
  targetType?: string;
  unsafeTypes: string[];
  files: string[];
  totalOccurrences: number;
  confidence: number;
  guardTemplate: string;
}

interface GuardMap {
  generatedAt: string;
  totalPatterns: number;
  guardClusters: TypeGuardCluster[];
  config: {
    minClusterSize: number;
    minConfidence: number;
  };
}

interface GeneratedGuard {
  guardName: string;
  guardCode: string;
  confidence: number;
  usageCount: number;
  affectedFiles: string[];
}

function generateGuards(guardMap: GuardMap, config: any): GeneratedGuard[] {
  const generated: GeneratedGuard[] = [];

  for (const cluster of guardMap.guardClusters) {
    // Skip low-confidence guards
    if (cluster.confidence < config.thresholds.minGuardConfidence) {
      console.log(`   âš ï¸  Skipping ${cluster.guardName} (confidence ${cluster.confidence.toFixed(2)} < ${config.thresholds.minGuardConfidence})`);
      continue;
    }

    const guardCode = cluster.guardTemplate;

    generated.push({
      guardName: cluster.guardName,
      guardCode,
      confidence: cluster.confidence,
      usageCount: cluster.totalOccurrences,
      affectedFiles: cluster.files,
    });
  }

  return generated.sort((a, b) => b.usageCount - a.usageCount);
}

function buildGuardFile(guards: GeneratedGuard[]): string {
  const header = `/**
 * Type Guards - Auto-generated Runtime Type Validators
 * Generated by Stage 4.2a Type-Guard Synthesis
 *
 * These guards provide runtime safety for property access patterns
 * that TypeScript's static analysis cannot verify.
 *
 * @generated ${new Date().toISOString()}
 */

`;

  const guardBlocks = guards.map(g => {
    return `/**
 * Runtime guard for ${g.guardName}
 * Confidence: ${(g.confidence * 100).toFixed(0)}% | Usage: ${g.usageCount} locations
 */
${g.guardCode}
`;
  });

  return header + guardBlocks.join("\n\n");
}

function main() {
  const args = process.argv.slice(2);
  const dryRun = !args.includes("--apply");

  console.log(`ðŸ§©  Generating type guards ${dryRun ? "(dry-run)" : "(applying)"}â€¦`);

  if (!fs.existsSync(MAP_PATH)) {
    console.error(`âŒ  Missing ${MAP_PATH}. Run analyze-type-guards.ts first.`);
    process.exit(1);
  }

  const guardMap: GuardMap = JSON.parse(fs.readFileSync(MAP_PATH, "utf8"));
  const config = JSON.parse(fs.readFileSync(CONFIG_PATH, "utf8"));

  console.log(`   Processing ${guardMap.guardClusters.length} guard candidatesâ€¦`);

  const generated = generateGuards(guardMap, config);

  console.log(`   âœ…  Generated ${generated.length} type guards.`);

  // Save templates artifact
  fs.mkdirSync(path.dirname(TEMPLATES_PATH), { recursive: true });
  fs.writeFileSync(
    TEMPLATES_PATH,
    JSON.stringify(
      {
        generatedAt: new Date().toISOString(),
        totalGuards: generated.length,
        guards: generated,
        dryRun,
      },
      null,
      2
    )
  );

  console.log(`ðŸ“„  Guard templates â†’ ${TEMPLATES_PATH}`);

  if (!dryRun) {
    // Write to actual guard file
    const guardFileContent = buildGuardFile(generated);
    fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
    fs.writeFileSync(OUTPUT_FILE, guardFileContent);
    console.log(`âœ…  Type guards written â†’ ${OUTPUT_FILE}`);
  } else {
    console.log(`   (Dry-run: no files modified)`);
  }

  // Summary
  console.log(`\nðŸ“Š  Generation Summary:`);
  console.log(`   Total guards: ${generated.length}`);
  console.log(`   Avg confidence: ${(generated.reduce((sum, g) => sum + g.confidence, 0) / generated.length * 100).toFixed(0)}%`);
  console.log(`   Total usage count: ${generated.reduce((sum, g) => sum + g.usageCount, 0)}`);

  if (generated.length > 0) {
    console.log(`\n   Top guards by usage:`);
    generated.slice(0, 5).forEach((g, i) => {
      console.log(`   ${i + 1}. ${g.guardName} (${g.usageCount} uses, ${(g.confidence * 100).toFixed(0)}% confidence)`);
    });
  }
}

main();
